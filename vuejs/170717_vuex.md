## 들어가며
본 글은 Vue.js 의 컴포넌트 구조화 및 각 통신을 이해하신 분들에게 적합한 문서입니다.
Vue.js 에 막 입문하시는 분들께는 [vue-입문](https://joshua1988.github.io/web_dev/vuejs-tutorial-for-beginner/) 가이드를 먼저 읽어보시길 권고드립니다.

## Vuex 란?
Vue.js 의 **상태관리** 를 위한 패턴이자 라이브러리

## 상태관리 (State Management) 가 왜 필요한가?
컴포넌트 기반 프레임워크에서는 화면 구성을 위해 화면 단위를 매우 잘게 쪼개서 컴포넌트화 하여 사용하게 된다. 예를 들면, header, button, list 등의 작은 단위가 컴포넌트 화 되어 한 화면 당 많은 컴포넌트를 사용하게 되고, 이에 따라 **컴포넌트 간의 통신이나 데이터 전달을 좀 더 유기적으로 관리할 필요성이 생긴다.** 유사한 프론트엔드 프레임워크인 React 에서는 이미 Redux, Flux 와 같은 상태 라이브러리를 사용하고 있고, Vue 도 따라서 Vuex 라는 상태관리 라이브러리를 사용하게 된다.

## 상태관리 패턴
상태관리 구성요소는 크게 3가지가 있다.

- state : 컴포넌트 간 공유될 data
- view : 데이터가 표현될 template
- actions : 사용자의 입력에 따라 반응할 methods

```jsx
new Vue({
  // state
  data () {
    return {
      count: 0
    }
  },
  // view
  template: `
    <div>{{ count }}</div>
  `,
  // actions
  methods: {
    increment () {
      this.count++
    }
  }
})
```

위 구성요소는 아래와 같이 동작한다.

![vue-state-one-way-data-flow]()

## 상태관리는 중대형 규모의 앱 컴포넌트들을 더 효율적으로 관리하기 위한 기법이다.

일반적으로 앱의 규모가 커지면서 생기는 문제점들은 아래와 같다.

1. Vue 의 기본 컴포넌트 통신방식인 **상위 - 하위** 에서 중간에 거쳐야 할 컴포넌트가 많아지거나
2. 이를 피하기 위해 Event Bus 를 활용하여 **상하위 관계가 아닌 컴포넌트 간** 통신 시 관리가 되지 않는 점

이러한 문제점들을 해결하기 위해 모든 데이터 통신 (state) 를 한 곳에서 중앙 집중식으로 관리한다.

![vuex-diagram]()

## Getting Started


## State


## Getters
- 각 컴포넌트에서 Vuex 의 데이터를 접근하여 변경하고 싶을 때의 로직들을 저장
- `import mapGetters from 'vuex'` 를 이용하여 computed 의 기존 메서드와 함께 사용할 수 있다.

```js
import {mapGetters} from 'vuex';

export default {
  computed: {
    ...mapGetters([
      'doubleCounter',
      'stringCounter'
    ])
  }
}
```

> 다만 Babel stage-2 라이브러리 추가 및 babel preset 에 추가 필요

## Mutations
-


## Actions
- Mutation 의 로직은 순차적으로 일어나야 각 컴포넌트의 반영 여부를 제대로 추적할 수가 있다.
- 따라서, `setTimeout()` 이나 서버와의 http 통신을 사용할 수 없게 되는데, 이를 위해 Actions 를 추가하여 비동기 로직을 추가할 수 있다.

```js
import {mapActions} from 'vuex';

export default {
  methods: {
    ...mapActions([
      'asyncIncrement',
      'asyncDecrement'
    ])
  },
}
```

- Actions 에 인자는 아래와 같이 넘긴다.

```html
<!-- by 와 duration 등의 여러 인자 값을 넘길 경우, 객체안에 key - value 형태로 여러 값을 넘길 수 있다 -->
<button @click="asyncIncrement({ by: 50, duration: 500})">Increment</button>
```

```js
export const store = new Vuex.Store({
  // ...
  actions: {
    asyncIncrement: ({ commit }, payload) => {
      setTimeout (() => {
        commit('increment', payload.by);
      }, payload.duration);
    }
  }
  // ...
})
```

## 대형 애플리케이션 제작을 위한 폴더 구조화 & NameSpacing
- 중간 크기 이상의 복잡한 앱을 제작할 때 `getters & mutations & actions` 의 이름을 유일하게 정하지 않으면 namespace 충돌이 난다. 따라서, 네임스페이스를 구분하기 위해 `types.js` 로 각 속성의 이름들을 빼고, `store.js` 와 각 컴포넌트에 import 하여 사용하는 방법이 있다.
- 생각보다 복잡하므로, 중대형 이상의 규모에서만 사용하는게 좋을듯. 배보다 배꼽이 클 수 있음

## Udemy
